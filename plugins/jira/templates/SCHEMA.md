<!-- Generated by Claude Sonnet 4.5 (Anthropic) - December 2025 -->

# Jira Template Schema

This document defines the YAML schema for Jira issue templates used by the `/jira:create` command.

## Overview

Templates drive the entire issue creation workflow:
- Define required fields and their prompts
- Generate interactive collection workflows
- Provide validation rules
- Specify formatting and defaults

## Template File Structure

```yaml
# Metadata (required)
# Identifies the template and tracks its version history
name: template-name
description: Human-readable description
version: 1.0.0
created: YYYY-MM-DD
author: author-name

# Inheritance (optional)
# Inherit fields and defaults from another template (child overrides parent)
inherits: path/to/parent.yaml

# Source tracking (optional)
# Records where this template came from for updates and attribution
source:
  repository: "https://github.com/..."
  path: "path/to/template.yaml"

# Educational content reference (optional)
# Links to documentation that provides guidance on this issue type
documentation:
  guide: "../../docs/issue-types/epic.md"
  description: "Guide on epics: what they are, best practices, and anti-patterns"

# Target configuration (optional)
# Specifies which Jira project and issue type this template creates
project_key: PROJECTKEY
issue_type: Epic|Story|Task|Bug|Spike|Feature

# Default field values (optional)
# Pre-populate Jira fields with team conventions and standards
defaults:
  priority: Normal
  components:
    - ComponentName
  labels:
    - ai-generated-jira
  target_version: openshift-4.22

# Display format (optional)
# Controls which fields appear in issue summary output after creation
display_format:
  - priority
  - summary
  - assignee
  - status

# Description template with Mustache syntax (required)
# Defines the structure of the Jira issue description using collected placeholders
description_template: |
  {{placeholder_name}}

  **Section Header**

  {{#list_placeholder}}
  * {{.}}
  {{/list_placeholder}}

  {{#optional_section}}
  **Optional Section**
  {{optional_section}}
  {{/optional_section}}

# Placeholder definitions (required only if referenced in description_template)
# Defines what information to collect from the user and how to prompt for it
placeholders:
  - name: placeholder_name
    description: "Prompt text shown to user"
    required: true|false
    type: text|list|multiline
    default: "default value"
    # ... additional metadata

# Jira field mappings (optional)
# Maps collected placeholders to specific Jira fields and sets field requirements
jira_fields:
  versions:
    source: placeholder_name
    required: true
  components:
    required: true
    prompt_if_missing: true
  customfield_12345:
    source: placeholder_name
    required: false

# Validation rules (optional)
# Enforces quality standards on issue fields before creation
validation:
  summary:
    max_length: 100
    should_start_with_verb: true
    should_not_contain:
      - "As a"
      - "I want"
    should_contain:
      - "[Docs]"
  version:
    required: true
  component:
    required: true
```

**Validation structure:** Each field can have its own validation rules under `validation.<field_name>.*`. Common validations:
- `max_length`: Maximum character length
- `required`: Whether the field is required
- `should_start_with_verb`: Summary should start with action verb (task convention)
- `should_not_contain`: List of strings that should not appear in the field
- `should_contain`: List of strings that must appear in the field

## Template Inheritance

**Inheritance is the most important feature of the template system.** It allows you to build specialized templates by extending base templates, avoiding duplication and ensuring consistency.

### Structure Requirements

**Template blocks must appear in this order:**
1. **Metadata** (required) - `name`, `description`, `version`, `created`, `author`
2. **Inheritance** (strongly recommended) - `inherits: path/to/parent.yaml`
3. All other sections - `defaults`, `description_template`, `placeholders`, etc.

**Example:**
```yaml
# Metadata (required)
name: ocpedge-spike
description: OCPEDGE team spike template
version: 1.0.0
created: 2025-01-08
author: ocpedge-team

# Inheritance (second block - strongly recommended)
inherits: common/spike.yaml

# Everything else follows
defaults:
  labels:
    - ai-generated-jira
    - team:ocpedge
```

### How Inheritance Works

Templates form a hierarchy where child templates inherit all fields from their parent and can override specific values:

```text
_base.yaml (foundation)
    â†“
common/spike.yaml (adds spike-specific structure)
    â†“
ocpedge/spike.yaml (adds OCPEDGE team conventions)
```

**Child overrides parent:**
- If both define the same field, child value wins
- Arrays and objects are **replaced** (not merged)
- Placeholders with the same `name` are **merged** (child fields override parent fields)

**Example override:**
```yaml
# common/spike.yaml (parent)
placeholders:
  - name: research_questions
    description: "What questions need answering?"
    required: false
    type: list

# ocpedge/spike.yaml (child)
inherits: common/spike.yaml
placeholders:
  - name: research_questions
    required: true  # Override: make it required
    # Inherits: description, type from parent
```

### Inheritance Paths

Templates can inherit from:
- `_base.yaml` - Foundation for all templates
- `common/<type>.yaml` - Product-level base (bug, epic, story, task, spike, feature, rfe)
- `<team>/<type>.yaml` - Team-specific template

**Common patterns:**

| Template Type | Typical Inheritance Chain |
|---------------|---------------------------|
| Team template | `_base.yaml â†’ common/epic.yaml â†’ ocpedge/epic.yaml` |
| Product template | `_base.yaml â†’ common/bug.yaml â†’ common/ocpbugs-bug.yaml` |
| Override file | `_base.yaml â†’ ocpedge/overrides.yaml` (applies to multiple types) |

### When to Use Inheritance

**Use inheritance when:**
- Creating team-specific versions of standard templates
- Building product-specific templates (OCPBUGS, RHEL, OSDOCS)
- Avoiding duplication of common fields and structure

**Don't use inheritance when:**
- Creating the base template (`_base.yaml`)
- Template is completely unique with no shared structure

### Validation

The template validator checks:
- No circular inheritance (A â†’ B â†’ A)
- Parent templates exist
- Inheritance chains are valid

For more details, see the [Template Management Skill](../skills/template-management/SKILL.md).

## Placeholder Schema

Each placeholder in the `placeholders` array defines one piece of information to collect from the user.

**Example use case:** You want users to specify "acceptance criteria" when creating an epic. The placeholder collects this information interactively, then inserts it into the Jira description.

**Simple example** (from line 84 above):
```yaml
placeholders:
  - name: acceptance_criteria
    description: "What are the key outcomes that define success?"
    required: true
    type: list
```

This creates an interactive prompt that collects multiple acceptance criteria items, then makes them available in the description template via `{{acceptance_criteria}}`.

### Core Fields

The fields below define metadata for a single placeholder (like the `acceptance_criteria` example above):

#### `name` (required)

Internal identifier used to reference this placeholder in the description template.

**Example:**
```yaml
placeholders:
  - name: acceptance_criteria
    description: "What defines success?"
```

Used in template as: `{{acceptance_criteria}}`

| Property | Value |
|----------|-------|
| **Type** | string |
| **Examples** | `"user_role"`, `"acceptance_criteria"`, `"target_version"` |

#### `description` (required)

Use this as the default prompt text shown to users when collecting this value.

**Example:**
```yaml
placeholders:
  - name: user_role
    description: "Who is the user? (e.g., cluster admin, developer)"
```

| Property | Value |
|----------|-------|
| **Type** | string |
| **Note** | Can be overridden by `prompt_text` for specialized wording |

#### `required` (optional)

Use this to enforce that users must provide a value for this placeholder.

**Example:**
```yaml
placeholders:
  - name: acceptance_criteria
    description: "What defines success?"
    required: true  # User must provide at least one criterion
```

| Property | Value |
|----------|-------|
| **Type** | boolean |
| **Default** | `false` |

#### `type` (optional)

Use this to specify how the user provides input and how the data is structured.

**Example:**
```yaml
placeholders:
  - name: acceptance_criteria
    type: list  # Collects multiple items, one per line
  - name: background
    type: multiline  # Collects multi-line text block
  - name: user_role
    type: text  # Collects single-line text (default)
```

| Property | Value |
|----------|-------|
| **Type** | enum |
| **Values** | `text` (single-line), `list` (multiple items), `multiline` (text block) |
| **Default** | `text` |

#### `default` (optional)

Use this to provide a default value when the user doesn't provide one.

**Example:**
```yaml
placeholders:
  - name: priority
    default: "Normal"
  - name: labels
    type: list
    default: []  # For lists, use empty array for no defaults
```

| Property | Value |
|----------|-------|
| **Type** | string or array (for lists) |
| **Note** | For list types, use `[]` for no default items |

### Interactive Prompting Fields

#### `prompt_text` (optional)

Use this when you want specific prompt wording that doesn't match the description reference text.

**Example:**
```yaml
placeholders:
  - name: acceptance_criteria
    description: "List of acceptance criteria (one per line)"
    prompt_text: "What are the key outcomes that define this epic as complete?"
```

| Property | Value |
|----------|-------|
| **Type** | string |
| **Use when** | Description is for reference, but prompt needs different wording |

#### `prompt_type` (optional)

Use this to control how interactively the value is collected from the user.

**Example:**
```yaml
placeholders:
  - name: epic_size
    prompt_type: suggestion  # Generate a suggestion based on summary
  - name: user_story
    prompt_type: guided  # Ask sub-questions to build the value
```

| Property | Value |
|----------|-------|
| **Type** | enum |
| **Values** | `simple`, `guided`, `suggestion`, `options` |
| **Default** | `simple` |
| **Behaviors** | `simple` (ask with prompt), `guided` (sub-questions), `suggestion` (generate suggestion), `options` (present choices) |

#### `prompt_with_suggestion` (optional)

Use this to generate a suggested value that the user can accept or modify.

**Example:**
```yaml
placeholders:
  - name: epic_label
    prompt_with_suggestion: true
    suggestion_template: "Generate from summary: extract key nouns/action, max 3-5 words"
```

| Property | Value |
|----------|-------|
| **Type** | boolean or object |
| **Requires** | `suggestion_template` to describe generation logic |

#### `prompt_with_options` (optional)

Use this to present a menu of predefined choices for the user to select from.

**Example:**
```yaml
placeholders:
  - name: epic_size
    prompt_with_options:
      - value: "XS"
        description: "Extra Small - About 1 sprint"
      - value: "S"
        description: "Small - About 2 sprints"
      - value: "M"
        description: "Medium - About 1 quarter"
```

| Property | Value |
|----------|-------|
| **Type** | array of objects |
| **Option fields** | `value` (required), `description` (required), `keywords` (optional for auto-detection) |

#### `guided_questions` (optional)

Use this to break down complex input into smaller sub-questions that get assembled into the final value.

**Example:**
```yaml
placeholders:
  - name: user_story
    prompt_type: guided
    guided_questions:
      - "Who is the user or role?"
      - "What do they want to do?"
      - "Why do they want it?"
    assembly_template: "As a {{q1}}, I want to {{q2}}, so that {{q3}}."
```

| Property | Value |
|----------|-------|
| **Type** | array of strings |
| **Requires** | `prompt_type: guided` and `assembly_template` |

### Auto-Detection Fields

Auto-detection allows templates to automatically select option values based on keywords found in the summary or description.

#### `auto_detect` (optional)

Use this to enable automatic selection of options based on keywords in the user's input.

**Example:**
```yaml
placeholders:
  - name: component
    auto_detect:
      search_in: ["summary", "description"]
      prompt_on_no_match: true
    prompt_with_options:
      - value: "HyperShift / ROSA"
        description: "ROSA HCP (AWS Hosted Control Planes)"
        keywords:
          - pattern: ["rosa", "aws", "rosa hcp"]
            confirm: false  # Auto-select silently
      - value: "HyperShift / ARO"
        description: "ARO HCP (Azure Hosted Control Planes)"
        keywords:
          - pattern: ["aro", "azure"]
```

| Property | Value |
|----------|-------|
| **Type** | object |
| **Sub-fields** | `search_in`, `prompt_on_no_match`, `confirmation_prompt` |

**Sub-field details:**

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `search_in` | array | `["summary", "description"]` | Where to search for keywords |
| `prompt_on_no_match` | boolean | `true` | Prompt user if no keywords match |
| `confirmation_prompt` | string | (auto-generated) | Custom confirmation message (supports `{{value}}`) |

#### `keywords` (optional, within `prompt_with_options`)

Use this within option definitions to specify which keywords trigger auto-selection of that option.

**Example:**
```yaml
prompt_with_options:
  - value: "HyperShift / ROSA"
    description: "ROSA HCP (AWS Hosted Control Planes)"
    keywords:
      - pattern: ["rosa", "aws", "rosa hcp"]
        confirm: false  # Auto-select silently
      - pattern: ["amazon"]
        confirm: true   # Ask user to confirm
```

| Property | Value |
|----------|-------|
| **Type** | array of keyword objects |
| **Keyword fields** | `pattern` (required), `confirm` (optional) |

**Keyword object fields:**

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `pattern` | array of strings | required | Keywords to match (case-insensitive) |
| `confirm` | boolean | `false` | Ask user confirmation when matched |

#### Auto-Detection Behavior

**When auto_detect is enabled:**

1. **Search Phase:**
   - Search in specified fields (summary, description) for keyword patterns
   - Match is case-insensitive and checks if keyword appears anywhere in text

2. **Matching:**
   - If keywords with `confirm: false` match â†’ Auto-select silently
   - If keywords with `confirm: true` match â†’ Auto-select and prompt for confirmation
   - If no keywords match and `prompt_on_no_match: true` â†’ Show all options for user selection
   - If no keywords match and `prompt_on_no_match: false` â†’ Leave field empty (or use default)

3. **Priority:**
   - First match wins (options are evaluated in order)
   - If multiple keyword patterns match the same option, use the first matched pattern's `confirm` setting

**Example:**
```yaml
placeholders:
  - name: platform
    required: true
    prompt_type: options
    prompt_with_options:
      - value: "AWS"
        description: "Amazon Web Services"
        keywords:
          - pattern: ["aws", "amazon", "ec2"]
      - value: "Azure"
        description: "Microsoft Azure"
        keywords:
          - pattern: ["azure", "microsoft cloud"]
      - value: "Multi-cloud"
        description: "Affects multiple platforms"
        keywords:
          - pattern: ["multi-cloud", "all platforms", "aws and azure"]
            confirm: true  # Less certain, ask user
    auto_detect:
      enabled: true
      # search_in defaults to ["summary", "description"]
      # prompt_on_no_match defaults to true
```

**Scenarios:**
- Summary: "Fix ROSA HCP autoscaling bug" â†’ Auto-selects "HyperShift / ROSA" silently
- Summary: "Multi-cloud metrics dashboard" â†’ Auto-detects "Multi-cloud", prompts: "Auto-detected 'Multi-cloud' based on keywords. Is this correct?"
- Summary: "Improve control plane scheduling" â†’ No match, shows all options for user to choose

### Validation Fields

#### `validation` (optional)
- **Type:** object
- **Description:** Validation rules for this placeholder
- **Fields:**
  ```yaml
  validation:
    min_length: 10
    max_length: 100
    pattern: "^[A-Z].*"  # Regex pattern
    min_items: 2  # For lists
    max_items: 10  # For lists
    allowed_values: ["Always", "Sometimes", "Rarely"]
  ```

### Help and Examples

#### `help_text` (optional)
- **Type:** string
- **Description:** Extended help shown if user asks "help" or "?"
- **Example:**
  ```yaml
  help_text: |
    Acceptance criteria define when the epic is complete.
    Focus on capabilities, not implementation.
    Should be measurable/demonstrable.
    Typically 3-6 criteria.
  ```

#### `examples` (optional)
- **Type:** array of strings
- **Description:** Example values to show user
- **Example:**
  ```yaml
  examples:
    - "Administrators can view metrics from all clusters"
    - "Alert rules fire based on cross-cluster conditions"
  ```

### Field Mapping Fields

#### `field` (optional)
- **Type:** string
- **Description:** Jira field ID to map this placeholder to
- **Example:** `"customfield_12311141"` (Epic Name)

#### `placeholder_name` (optional)
- **Type:** string
- **Description:** For placeholders that expand to template content
- **Used with:** `placeholder_content`
- **Example:**
  ```yaml
  - name: additional_spikes_link
    placeholder_name: additional_spikes_placeholder
    placeholder_content: "* [Additional Spikes|https://...]"
  ```

## Project Overrides

Project overrides allow teams to apply project-wide conventions to common templates without creating duplicate template files for each issue type.

### When to Use Overrides

Use overrides when:
- You need the same placeholder/behavior across multiple issue types
- You want to enforce project-specific requirements (e.g., component selection)
- You don't want to maintain separate templates for each issue type

**Example:** HyperShift team requires platform component selection (ARO/ROSA) for all issues. Instead of creating 5 templates (story, task, spike, bug, epic), create one `overrides.yaml`.

### Override File Structure

**Location:** `{project}/overrides.yaml`

**Example:** `hypershift/overrides.yaml`

```yaml
name: hypershift-overrides
description: HyperShift project-wide conventions
version: 1.0.0
project_key: CNTRLPLANE

# Top-level applies_to: default for all fields
applies_to:
  - "common/bug.yaml"
  - "common/epic.yaml"
  - "common/spike.yaml"
  - "common/task.yaml"
  - "common/story.yaml"

# Component requirements inherit top-level applies_to
jira_fields:
  components:
    required: true
    prompt_if_missing: true

# Labels override with field-specific applies_to
defaults:
  labels:
    - ai-generated-jira
    - hypershift
  applies_to:  # Field-specific: apply to ALL common templates
    - "common/*.yaml"
```

### Cascading `applies_to`

Overrides support **cascading `applies_to` patterns**:

1. **Top-level `applies_to`**: Default pattern for all fields
2. **Field-specific `applies_to`**: Overrides the top-level pattern for that field

**Example use case:** You want to add a label to all common templates (including product templates like `ocpbugs-bug`), but only require components for base templates:

```yaml
# Top-level: most overrides apply only to base templates
applies_to:
  - "common/bug.yaml"
  - "common/epic.yaml"
  - "common/spike.yaml"
  - "common/task.yaml"
  - "common/story.yaml"

# Component requirement uses top-level applies_to
# Will NOT apply to ocpbugs-bug (not in top-level list)
jira_fields:
  components:
    required: true

# Label override uses field-specific applies_to
# WILL apply to ocpbugs-bug (matches common/*.yaml)
defaults:
  labels:
    - ai-generated-jira
    - hypershift
  applies_to:
    - "common/*.yaml"
```

**Result:**
- `common/bug.yaml` gets: component requirement + hypershift label
- `common/ocpbugs-bug.yaml` gets: hypershift label only (already has component logic)
- `common/feature.yaml` gets: nothing (excluded by both patterns)

### Template Loading with Overrides

When loading a template for project `HYPERSHIFT` and type `story`:

1. **Check for project-specific template:** `hypershift/story.yaml`
   - If exists: Load it (overrides **do not apply**)
   - If missing: Continue to step 2

2. **Load common template:** `common/story.yaml`

3. **Check for overrides:** `hypershift/overrides.yaml`
   - If exists and `common/story.yaml` matches `applies_to`:
     - Merge overrides into template
   - If missing or doesn't apply: Skip

4. **Apply inheritance:** Process any `inherits` directives

**Key rule:** Overrides **only apply** when using common templates. If you create `hypershift/story.yaml`, overrides are skipped for stories.

### applies_to Patterns

**Glob patterns** (recommended):
```yaml
applies_to:
  - "common/*.yaml"  # All common templates
```

**Specific files:**
```yaml
applies_to:
  - "common/story.yaml"
  - "common/epic.yaml"
  - "common/bug.yaml"
```

**All common templates** (omit field):
```yaml
# No applies_to field = applies to all common/* templates
```

### Override Merging Rules

Overrides merge using the same rules as template inheritance:

1. **Placeholders:** Merged by name (override placeholders with same name)
2. **Defaults:** Merged (override defaults override common defaults)
3. **Other fields:** Replaced (override value replaces common value)

**Example:**

```yaml
# common/story.yaml
placeholders:
  - name: user_role
    required: true
  - name: acceptance_criteria
    required: true

defaults:
  labels:
    - ai-generated-jira

# hypershift/overrides.yaml
placeholders:
  - name: hypershift_component  # Added
    required: true

defaults:
  labels:
    - ai-generated-jira
    - hypershift              # Added

# Result after merging:
placeholders:
  - name: user_role          # From common
  - name: acceptance_criteria # From common
  - name: hypershift_component # From overrides

defaults:
  labels:
    - ai-generated-jira
    - hypershift            # Merged from overrides
```

### Debugging Overrides

The template loader logs when overrides apply:

```text
Loading template for CNTRLPLANE story...
  âœ“ Found common/story.yaml
  âœ“ Applying hypershift/overrides.yaml
  â†’ Final template: common/story.yaml + hypershift/overrides.yaml
```

If a project-specific template exists:

```text
Loading template for CNTRLPLANE story...
  âœ“ Found hypershift/story.yaml
  â†’ Overrides skipped (using project-specific template)
```

## Description Template Syntax

Templates use Mustache syntax:

### Variables
```yaml
{{variable_name}}
```

### Conditional Sections
```yaml
{{#section_name}}
  Content shown if section_name is truthy
{{/section_name}}
```

### Lists
```yaml
{{#list_name}}
  * {{.}}
{{/list_name}}
```

### Inverted Sections
```yaml
{{^section_name}}
  Content shown if section_name is falsy
{{/section_name}}
```

## Complete Example

For a complete working template example, see:
- **[common/epic.yaml](common/epic.yaml)** - Base epic template with scope and acceptance criteria
- **[common/ocpbugs-bug.yaml](common/ocpbugs-bug.yaml)** - OCPBUGS bug template with auto-detection
- **[ocpedge/overrides.yaml](ocpedge/overrides.yaml)** - Team-specific overrides example

## Documentation Reference Field

### `documentation` (optional)

Templates can reference educational content that provides context and guidance:

```yaml
documentation:
  guide: "../../docs/issue-types/epic.md"
  description: "Comprehensive guide on epics: what they are, best practices, and anti-patterns"
  sections:
    - what_is: "What is an Epic?"
    - best_practices: "Epic Best Practices"
    - anti_patterns: "Anti-Patterns to Avoid"
```

**When to use:**
- Link to detailed educational content
- Provide context about the issue type
- Reference best practices and anti-patterns

**How it's used:**
1. **Before prompting**: Show user a link to the guide
   ```
   Creating Epic issue for PROJECT

   ðŸ“– For guidance, see: docs/issue-types/epic.md
      "Comprehensive guide on epics: what they are, best practices, and anti-patterns"

   Let's start...
   ```

2. **In help text**: Reference specific sections
   ```
   For more about epic acceptance criteria, see:
   docs/issue-types/epic.md#best_practices
   ```

3. **On errors**: Point to relevant guidance
   ```
   Epic seems too large (>5 sprints). See docs/issue-types/epic.md#anti_patterns
   for guidance on epic sizing.
   ```

## Reference Docs

For educational content about each issue type:
- `docs/issue-types/epic.md` - What is an Epic, best practices, anti-patterns
- `docs/issue-types/story.md` - User story guidelines, acceptance criteria formats
- `docs/issue-types/task.md` - Task vs story distinction, when to use each
- `docs/issue-types/bug.md` - Bug reporting best practices, reproduction steps
- `docs/issue-types/feature.md` - Feature vs epic distinction, strategic planning
- `docs/issue-types/spike.md` - Spike guidelines, research vs implementation
