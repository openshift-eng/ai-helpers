---
name: Create Jira Issue (Template-Driven)
description: Unified skill for creating all Jira issue types using template-driven workflows
---
<!-- Generated by Claude Sonnet 4.5 (Anthropic) - December 2025 -->

# Create Jira Issue - Template-Driven Workflow

This skill provides a unified, template-driven workflow for creating all Jira issue types (Epic, Story, Task, Bug, Spike, Feature, Feature Request).

## When to Use This Skill

This skill is automatically invoked by the `/jira:create` command for all issue types.

## How It Works

1. **Template Selection**: Automatically selects the appropriate template based on project + issue type
2. **Dynamic Prompting**: Generates interactive prompts from template placeholder metadata
3. **Validation**: Applies validation rules defined in the template
4. **Issue Creation**: Creates the issue via MCP with all collected information

## Template-Driven Approach

Instead of hardcoding workflows for each issue type, this skill:
- Reads the template YAML file
- Extracts placeholder definitions
- Generates prompts dynamically from metadata
- Validates input based on template rules
- Formats the description using the template

**Benefits:**
- Single source of truth (templates)
- Consistent behavior across all issue types
- New issue types work automatically
- Template changes immediately reflected

## Workflow Overview

```
0. MCP Server Verification (first-time or reconnection)
   - Check if atlassian MCP tools are available
   - If not available and first time: offer guided setup
   - If not available but flag set: offer reconnection troubleshooting
   - Set mcp_setup_complete flag before requesting restart
   - See commands/create.md Phase 0 for complete workflow

1. Parse command arguments (project, type, summary, flags)
2. Load template (project-specific â†’ common fallback)
3. Show educational guide reference (if template has documentation field)
4. Scan and describe template to user
5. Apply template defaults
6. Prompt for priority (all issue types)
7. Interactive placeholder collection (template-driven)
8. Validate summary format
9. Security validation
10. Create issue via MCP
11. Return result
```

**See [commands/create.md Phase 0](../../commands/create.md#-phase-0-mcp-server-verification-first-time-setup) for detailed MCP verification workflow.**

## Educational Content Integration

Templates can reference educational documentation:

```yaml
documentation:
  guide: "../../docs/issue-types/epic.md"
  description: "Comprehensive guide on epics: what they are, best practices, and anti-patterns"
```

**At workflow start**, display the guide reference:
```
Creating Epic issue for OCPEDGE

ðŸ“– For guidance, see: docs/issue-types/epic.md
   "Comprehensive guide on epics: what they are, best practices, and anti-patterns"

Using template: common-epic (common/epic.yaml)

Let's start...
```

**During prompting**, reference specific sections in help text:
```
What are the key outcomes that define this epic as complete?

[?] For help: Epic acceptance criteria are high-level outcomes...
    See docs/issue-types/epic.md#acceptance-criteria for examples.
```

**On validation errors**, point to relevant guidance:
```
âš ï¸  Epic seems too large (estimated >5 sprints).
    Consider splitting into multiple epics or creating as a Feature.
    See docs/issue-types/epic.md#sizing for guidance.
```

## Template Description (Step 4)

Before collecting placeholder values, describe the template to the user. This demonstrates that template interpolation is working and sets expectations for what will be collected.

**Display:**
1. Template name and source file
2. Template inheritance chain (if inherited)
3. Complete list of placeholders that will be collected
4. Which placeholders are required vs optional
5. Brief description of each placeholder
6. **Source template file for each placeholder** (shows inheritance)

**Example output for simple template:**
```
Using template: common-epic (common/epic.yaml)
  Inherits from: _base.yaml

This template will collect the following information:

Required fields:
  â€¢ epic_name (common/epic.yaml) - Short identifier for this epic
  â€¢ objective (common/epic.yaml) - Epic objective describing the capability
  â€¢ acceptance_criteria (common/epic.yaml) - High-level outcomes (2-8 items)
  â€¢ in_scope (common/epic.yaml) - What is included in this epic (1+ items)
  â€¢ target_release (common/epic.yaml) - Target release (e.g., Q1 2025, OpenShift 4.18)

Optional fields:
  â€¢ out_of_scope (common/epic.yaml) - What is NOT included (default: none)
  â€¢ size (common/epic.yaml) - Epic size estimate (default: M)
  â€¢ additional_context (common/epic.yaml) - Design docs, dependencies (default: none)

Let's begin collecting this information...
```

**For inherited templates with overrides**, show which template each field comes from:
```
Using template: ocpedge-spike (ocpedge/spike.yaml)
  Inherits from: common-spike (common/spike.yaml)
  Base template: _base.yaml

This template will collect the following information:

Required fields:
  â€¢ overview (ocpedge/spike.yaml) - Brief overview of the spike
  â€¢ research_questions (ocpedge/spike.yaml) - Research questions to investigate (one per line)
  â€¢ involved_teams (ocpedge/spike.yaml) - Teams involved (one per line)

Optional fields:
  â€¢ additional_spikes_link (ocpedge/spike.yaml) - Link to additional spikes document
  â€¢ design_proposal_link (ocpedge/spike.yaml) - Link to design proposal document
  â€¢ additional_context (ocpedge/spike.yaml) - Background, related issues (default: none)

Let's begin collecting this information...
```

**If fields came from different templates in the chain**, show mixed sources:
```
Required fields:
  â€¢ summary (common/story.yaml) - Short title for the story
  â€¢ user_role (common/story.yaml) - Who benefits from this story
  â€¢ action (common/story.yaml) - What the user wants to do
  â€¢ value (common/story.yaml) - Why the user wants it
  â€¢ acceptance_criteria (common/story.yaml) - Conditions for done (2-8 items)

Optional fields:
  â€¢ sprint (ocpedge/story.yaml) - Target sprint number
  â€¢ additional_context (common/story.yaml) - Design docs, background (default: none)
```

This summary:
- Confirms template loading worked correctly
- Shows placeholder interpolation is functioning
- **Demonstrates template inheritance** (which fields come from where)
- Warns user what to expect
- Helps user prepare information before being prompted
- Makes template system transparent and debuggable

## Interactive Collection Process

For each placeholder in the template:

### 1. Determine Prompt Type

Based on placeholder metadata:
- `prompt_type: suggestion` â†’ Generate suggestion, ask for confirmation
- `prompt_type: options` â†’ Present options to choose from
- `prompt_type: guided` â†’ Ask sub-questions, assemble answer
- `prompt_type: simple` (default) â†’ Direct prompt

### 2. Get Prompt Text

Priority order:
1. `prompt_text` (if specified)
2. `description` (fallback)

### 3. Show Help if Available

If `help_text` is defined and user types "?" or "help":
- Display the help text
- Show examples if available
- Re-prompt for value

### 4. Collect Value

Based on `type`:
- `text`: Single-line input
- `multiline`: Multi-line text block
- `list`: Multiple items, one per line

### 5. Validate Input

Apply validation rules from `validation`:
- `required`: Must have value
- `min_length` / `max_length`: Length constraints
- `min_items` / `max_items`: List size constraints
- `pattern`: Regex validation
- `allowed_values`: Enum validation

### 6. Use Default if Applicable

If user provides no value and `default` is specified:
- Use the default value
- Skip if not required

## Prompt Type Examples

### Simple Prompt

```yaml
placeholders:
  - name: task_description
    description: "What work needs to be done?"
    required: true
    type: text
```

**Execution:**
```
What work needs to be done?
> [user types answer]
```

### Suggestion Prompt

```yaml
placeholders:
  - name: epic_name
    prompt_type: suggestion
    prompt_with_suggestion: true
    suggestion_template: "Generate from summary: extract key nouns/action, max 3-5 words"
```

**Execution:**
```
Epic Name:
  Summary: "Enable graceful API server responses during planned maintenance"
  Suggested: "API Server Graceful Responses"

Use this epic name? (yes/no/custom)
> [user responds]
```

### Options Prompt

```yaml
placeholders:
  - name: size
    prompt_type: options
    prompt_text: "What is the estimated size?"
    prompt_with_options:
      - value: "S"
        description: "Small - About 2 sprints"
      - value: "M"
        description: "Medium - About 3 sprints"
```

**Execution:**
```
What is the estimated size?
1. S - Small - About 2 sprints
2. M - Medium - About 3 sprints
3. L - Large - About 4 sprints

Select option (1-3):
> [user selects]
```

### Options Prompt with Auto-Detection

When `auto_detect` is enabled, the system searches for keywords in the summary/description and automatically selects matching options.

```yaml
placeholders:
  - name: platform
    prompt_type: options
    prompt_with_options:
      - value: "HyperShift / ARO"
        description: "ARO HCP (Azure)"
        keywords:
          - pattern: ["aro", "azure"]
            # confirm: false is default
      - value: "HyperShift / ROSA"
        description: "ROSA HCP (AWS)"
        keywords:
          - pattern: ["rosa", "aws"]
      - value: "HyperShift"
        description: "Platform-agnostic"
        keywords:
          - pattern: ["multi-cloud", "all platforms"]
            confirm: true  # Ask user to confirm
    auto_detect:
      enabled: true
```

**Execution Examples:**

**Scenario 1: High-confidence auto-detection (confirm: false)**
```
Summary: "Fix ROSA HCP autoscaling bug"

[Auto-detects "HyperShift / ROSA" based on keyword "rosa"]
[Skips prompting - auto-selected silently]
```

**Scenario 2: Low-confidence auto-detection (confirm: true)**
```
Summary: "Multi-cloud metrics dashboard"

Auto-detected 'HyperShift' based on keywords. Is this correct? (yes/no)
> [user confirms or corrects]
```

**Scenario 3: No keyword match**
```
Summary: "Improve control plane scheduling"

Which HyperShift platform does this affect?
1. HyperShift / ARO - ARO HCP (Azure)
2. HyperShift / ROSA - ROSA HCP (AWS)
3. HyperShift - Platform-agnostic

Select option (1-3):
> [user selects]
```

**Behavior:**
- Keywords with `confirm: false` (default) â†’ Auto-select silently
- Keywords with `confirm: true` â†’ Auto-detect and prompt for confirmation
- No keywords match â†’ Show all options (default behavior)
- Matching is case-insensitive
- First match wins (options evaluated in order)
- `search_in` defaults to ["summary", "description"]
- `prompt_on_no_match` defaults to true

### Guided Prompt

```yaml
placeholders:
  - name: user_story
    prompt_type: guided
    guided_questions:
      - "Who is the user?"
      - "What do they want to do?"
      - "Why do they want it?"
    assembly_template: "As a {{q1}}, I want to {{q2}}, so that {{q3}}."
```

**Execution:**
```
Let's build the user story together.

Who is the user?
> cluster admin

What do they want to do?
> configure automatic node pool scaling

Why do they want it?
> to handle traffic spikes without manual intervention

User story:
  As a cluster admin, I want to configure automatic node pool scaling,
  so that I can handle traffic spikes without manual intervention.

Does this look correct? (yes/no/modify)
> [user confirms]
```

## Priority Prompting

**Always prompt for priority** (applies to all issue types):

```
What is the priority for this issue?

Common values:
  - Blocker, Urgent, Critical, Must Have, High
  - Major, Should Have
  - Normal (default)
  - Medium, Minor, Low, Could Have
  - Trivial, Optional

Priority: [Normal]
> [user enters or accepts default]
```

## OpenShift Version Handling

For OpenShift projects (CNTRLPLANE, OCPBUGS, etc.), version handling follows standard conventions.

### Version Normalization

Users may specify versions in various formats. Normalize all inputs to the Jira format `openshift-X.Y`:

| User Input | Normalized Output |
|------------|-------------------|
| `4.21` | `openshift-4.21` |
| `4.22.0` | `openshift-4.22` |
| `openshift 4.23` | `openshift-4.23` |
| `openshift-4.21` | `openshift-4.21` |
| `OCP 4.22` | `openshift-4.22` |
| `ocp 4.21` | `openshift-4.21` |
| `OpenShift 4.23` | `openshift-4.23` |

**Normalization rules:**
1. Convert to lowercase
2. Remove "ocp" or "openshift" prefix (with or without space/hyphen)
3. Extract version number (X.Y or X.Y.Z â†’ X.Y)
4. Prepend "openshift-"

### Target Version Field (customfield_12319940)

**Status:** OPTIONAL by default (templates can override to make it required)

**When specified**, follow this workflow:

1. **Normalize** the user input to `openshift-X.Y` format
2. **Fetch available versions:**
   ```python
   versions = mcp__atlassian__jira_get_project_versions(project_key=project_key)
   ```
3. **Find the version ID** for the normalized version name
4. **If version doesn't exist**, suggest closest match or ask user to confirm
5. **Use correct MCP format** (array of version objects with ID):
   ```python
   "customfield_12319940": [{"id": "VERSION_ID"}]  # e.g., openshift-4.22
   ```

**IMPORTANT:**
- Do NOT use string format like `"openshift-4.22"` - this will fail
- Must use array with version ID: `[{"id": "12448830"}]`

### Affects Version/s Field (versions)

**Purpose:** Version where a bug was found (bugs only)

**Format:**
```python
"versions": [{"name": "4.21"}]  # version name as string in array
```

**Note:** Unlike Target Version, Affects Version uses version NAME, not ID.

### Never Set Fix Version/s

The `fixVersions` field is managed by the release team and **must never be set** by issue creation workflows.

## Validation

### Template-Based Validation

Apply rules from `validation` block:

```yaml
validation:
  summary_max_length: 80
  summary_should_start_with_verb: true
  required_fields:
    - field_name
```

### Placeholder-Level Validation

Apply rules from placeholder's `validation`:

```yaml
placeholders:
  - name: acceptance_criteria
    type: list
    validation:
      min_items: 2
      max_items: 8
```

### Universal Validation

Always validate:
- Required placeholders have values
- Summary is not empty
- No sensitive data (credentials, keys, tokens)

## Description Formatting

For complete formatting guidelines (heading standards, MCP vs Direct API), see the [Jira Formatting section in the plugin README](../../README.md#jira-formatting).

### Template Rendering

1. Load description_template from template
2. Populate with collected placeholder values
3. Use Mustache rendering:
   - `{{name}}` â†’ Insert value
   - `{{#list}}...{{/list}}` â†’ Iterate list
   - `{{#optional}}...{{/optional}}` â†’ Show if truthy

## MCP Tool Parameters

### Basic Issue Creation

```python
mcp__atlassian__jira_create_issue(
    project_key="<PROJECT>",
    summary="<summary>",
    issue_type="<Epic|Story|Task|Bug|Spike|Feature>",
    description="<rendered template>",
    priority="<priority>",
    components="<component>",  # if specified
    additional_fields={
        "labels": ["ai-generated-jira", "template:<template-name>"],
        # Custom fields from template
        "customfield_12311141": "<epic_name>",  # if Epic
        "customfield_12320852": "<size>",  # if Epic with size
        # Parent linking if --parent flag
        "customfield_12313140": "<parent-key>",  # Epic â†’ Feature
        "customfield_12311140": "<epic-key>",  # Story/Task â†’ Epic
    }
)
```

### Field Mapping

Use `field` attribute from placeholder:

```yaml
placeholders:
  - name: epic_name
    field: customfield_12311141
```

Maps to:
```python
additional_fields["customfield_12311141"] = values["epic_name"]
```

## Error Handling

### Template Not Found

```
Could not find template for <project> <issue_type>.

Searched:
  1. ~/.jira-templates/<project>-<type>.yaml
  2. plugins/jira/templates/<project>/<type>.yaml
  3. plugins/jira/templates/common/<type>.yaml

Would you like to:
  1. Use a different template (specify path)
  2. Create issue without template
  3. Cancel
```

### Template Parse Error

Template file exists but contains invalid YAML syntax:

```
Failed to load template: ocpedge-spike.yaml
  YAML Parse Error: Line 45, Column 3: unexpected indent

The template file has a syntax error and cannot be parsed.

Would you like to:
  1. Edit the template to fix errors
  2. Use a different template
  3. Cancel
```

**Common causes:**
- Incorrect indentation (YAML requires consistent spaces, not tabs)
- Missing colons after keys
- Unmatched quotes or brackets
- Invalid characters in field names

**Debugging:**
- Use a YAML validator: `yamllint <template-file>`
- Check line number indicated in error
- Verify indentation is consistent (2 or 4 spaces, no tabs)

### Template Schema Violation

Template has valid YAML but violates the template schema:

```
Template validation failed: ocpedge-spike.yaml

Schema violations:
  - Missing required field: 'issue_type'
  - Invalid field type: 'defaults.priority' must be string, got list
  - Unknown placeholder referenced: 'unknown_field' used in description_template but not defined in placeholders

The template does not conform to the required schema.

Would you like to:
  1. Edit the template to fix violations
  2. Use a different template
  3. Cancel
```

**Common violations:**
- Missing required top-level fields: `name`, `description`, `version`, `issue_type`
- Wrong field types (e.g., string instead of list, object instead of string)
- Placeholder referenced in `description_template` but not defined in `placeholders`
- Invalid placeholder field types (must include `name` and `required`)
- Invalid validation rules (e.g., `min_items` on non-list field)

**See:** [Template Schema](../../templates/SCHEMA.md) for complete specification

### Circular Inheritance

Template inheritance creates a cycle:

```
Template inheritance cycle detected:

  team-epic.yaml â†’ common-epic.yaml â†’ team-epic.yaml

Templates cannot inherit from themselves, either directly or indirectly.

Please fix the inheritance chain in one of these templates:
  - team-epic.yaml
  - common-epic.yaml
```

**Common causes:**
- Template A inherits from B, B inherits from A (direct cycle)
- Template A inherits from B, B inherits from C, C inherits from A (indirect cycle)
- Typo in `inherits` path pointing to wrong template

**Fix:**
- Review inheritance chain
- Ensure linear inheritance (no cycles)
- Typical pattern: `team-template.yaml â†’ common/template.yaml â†’ _base.yaml`

### Missing Placeholder Reference

Template's `description_template` references undefined placeholder:

```
Template validation warning: ocpedge-epic.yaml

Undefined placeholder reference in description_template:
  - Template uses {{missing_field}} but no placeholder named 'missing_field' is defined

This will cause an error when rendering the description.

Would you like to:
  1. Edit the template to add the missing placeholder
  2. Edit the template to remove the reference
  3. Continue anyway (description will be incomplete)
```

**Common causes:**
- Typo in placeholder name in description_template
- Placeholder defined in parent but removed in child
- Copy-paste error from another template

**Fix:**
- Add missing placeholder to `placeholders` list
- Or remove `{{missing_field}}` from `description_template`
- Ensure placeholder names match exactly (case-sensitive)

### Invalid Placeholder Value

```
Invalid value for '<placeholder_name>':
  Error: Must be at least 2 items (got 1)

Please provide at least 2 <placeholder_description>:
> [retry]
```

### Required Field Missing

```
Required field '<placeholder_name>' has no value.

<description>

[Shows help_text if available]
[Shows examples if available]

> [prompt again]
```

### MCP Tool Error

```
Failed to create issue:
  Error: <mcp error message>

Suggested action: <based on error>
```

## Educational Content

For detailed guidance on each issue type, see:
- [Epic Best Practices](../../docs/issue-types/epic.md)
- [Story Best Practices](../../docs/issue-types/story.md)
- [Task Best Practices](../../docs/issue-types/task.md)
- [Bug Best Practices](../../docs/issue-types/bug.md)
- [Feature Best Practices](../../docs/issue-types/feature.md)
- [Spike Best Practices](../../docs/issue-types/spike.md)

## Implementation Notes

### Template Loading

```python
def load_template(project_key, issue_type):
    """Load template with inheritance."""
    search_paths = [
        f"~/.jira-templates/{project_key.lower()}-{issue_type.lower()}.yaml",
        f"plugins/jira/templates/{project_key.lower()}/{issue_type.lower()}.yaml",
        f"plugins/jira/templates/common/{issue_type.lower()}.yaml"
    ]

    for path in search_paths:
        if exists(path):
            template = load_yaml(path)
            if template.get('inherits'):
                parent = load_template_by_path(template['inherits'])
                template = merge_templates(parent, template)
            return template

    raise TemplateNotFoundError(f"No template found for {project_key} {issue_type}")
```

### Template Merging

The `merge_templates` function implements field-level merging for placeholders:

```python
def merge_templates(parent, child):
    """Merge child template into parent template."""
    merged = copy.deepcopy(parent)

    # Merge top-level fields (child overrides parent)
    for key, value in child.items():
        if key == 'placeholders':
            # Special handling: merge placeholders by name
            merged['placeholders'] = merge_placeholders(
                parent.get('placeholders', []),
                child.get('placeholders', [])
            )
        elif key == 'defaults':
            # Special handling: merge defaults
            merged['defaults'] = {**parent.get('defaults', {}), **child.get('defaults', {})}
        else:
            # Regular fields: child replaces parent
            merged[key] = value

    return merged

def merge_placeholders(parent_placeholders, child_placeholders):
    """Merge placeholder lists, with field-level merging for same-named placeholders."""
    # Index parent placeholders by name
    parent_by_name = {p['name']: p for p in parent_placeholders}

    # Index child placeholders by name
    child_by_name = {p['name']: p for p in child_placeholders}

    # Start with all parent placeholders
    merged = []
    for parent_ph in parent_placeholders:
        name = parent_ph['name']
        if name in child_by_name:
            # Field-level merge: child fields override parent fields
            merged_ph = {**parent_ph, **child_by_name[name]}
            merged.append(merged_ph)
        else:
            # Keep parent placeholder as-is
            merged.append(parent_ph)

    # Add any child-only placeholders
    for child_ph in child_placeholders:
        if child_ph['name'] not in parent_by_name:
            merged.append(child_ph)

    return merged
```

**Key behaviors:**
- Placeholders are matched by `name` field
- When names match, fields are merged (child overrides parent)
- Unspecified fields in child are inherited from parent
- Example: Child specifies `description` and `prompt_text`, inherits `type`, `required`, `default` from parent

See [Template Schema - Placeholder Field Merging](../../templates/SCHEMA.md#placeholder-field-merging) for details.

### Dynamic Prompting

```python
def collect_placeholder(placeholder, context):
    """Collect value for a placeholder based on its metadata."""
    prompt_type = placeholder.get('prompt_type', 'simple')

    if prompt_type == 'suggestion':
        return collect_with_suggestion(placeholder, context)
    elif prompt_type == 'options':
        return collect_with_options(placeholder)
    elif prompt_type == 'guided':
        return collect_with_guided_questions(placeholder)
    else:  # simple
        return collect_simple(placeholder)
```

### Validation

```python
def validate_placeholder(name, value, placeholder):
    """Validate placeholder value against rules."""
    validation = placeholder.get('validation', {})

    # Required check
    if placeholder.get('required') and not value:
        raise ValidationError(f"Required field '{name}' has no value")

    # Length checks (for text)
    if 'min_length' in validation:
        if len(value) < validation['min_length']:
            raise ValidationError(f"Must be at least {validation['min_length']} characters")

    # Item count checks (for lists)
    if 'min_items' in validation:
        if len(value) < validation['min_items']:
            raise ValidationError(f"Must have at least {validation['min_items']} items")

    # Pattern matching
    if 'pattern' in validation:
        if not re.match(validation['pattern'], value):
            raise ValidationError(f"Does not match required pattern")

    # Allowed values
    if 'allowed_values' in validation:
        if value not in validation['allowed_values']:
            raise ValidationError(f"Must be one of: {', '.join(validation['allowed_values'])}")
```

## See Also

- [Template Schema](../../templates/SCHEMA.md)
- [/jira:create Command](../../commands/create.md)
- [Template Management](../template-management/SKILL.md)
